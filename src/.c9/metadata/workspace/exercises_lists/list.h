{"filter":false,"title":"list.h","tooltip":"/exercises_lists/list.h","ace":{"folds":[],"scrolltop":9061.5,"scrollleft":0,"selection":{"start":{"row":344,"column":20},"end":{"row":344,"column":20},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":50,"state":"start","mode":"ace/mode/c_cpp"}},"hash":"de937c98a5a8ecd4ff946427339facc17518f785","undoManager":{"mark":100,"position":100,"stack":[[{"start":{"row":503,"column":23},"end":{"row":503,"column":30},"action":"remove","lines":["index-1"],"id":1705}],[{"start":{"row":503,"column":23},"end":{"row":503,"column":24},"action":"insert","lines":["v"],"id":1706}],[{"start":{"row":503,"column":24},"end":{"row":503,"column":25},"action":"insert","lines":["a"],"id":1707}],[{"start":{"row":503,"column":23},"end":{"row":503,"column":25},"action":"remove","lines":["va"],"id":1708},{"start":{"row":503,"column":23},"end":{"row":503,"column":26},"action":"insert","lines":["val"]}],[{"start":{"row":503,"column":28},"end":{"row":503,"column":41},"action":"remove","lines":["&& pos < size"],"id":1709}],[{"start":{"row":505,"column":0},"end":{"row":506,"column":0},"action":"remove","lines":["        pos++;",""],"id":1710}],[{"start":{"row":513,"column":8},"end":{"row":513,"column":11},"action":"remove","lines":["val"],"id":1711},{"start":{"row":513,"column":8},"end":{"row":513,"column":9},"action":"insert","lines":["t"]}],[{"start":{"row":513,"column":9},"end":{"row":513,"column":10},"action":"insert","lines":["r"],"id":1712}],[{"start":{"row":513,"column":10},"end":{"row":513,"column":11},"action":"insert","lines":["u"],"id":1713}],[{"start":{"row":513,"column":11},"end":{"row":513,"column":12},"action":"insert","lines":["e"],"id":1714}],[{"start":{"row":514,"column":0},"end":{"row":514,"column":1},"action":"remove","lines":["\t"],"id":1715}],[{"start":{"row":498,"column":0},"end":{"row":499,"column":0},"action":"remove","lines":["T val;",""],"id":1716}],[{"start":{"row":505,"column":0},"end":{"row":505,"column":1},"action":"insert","lines":["i"],"id":1717}],[{"start":{"row":505,"column":1},"end":{"row":505,"column":2},"action":"insert","lines":["f"],"id":1718}],[{"start":{"row":505,"column":2},"end":{"row":505,"column":3},"action":"insert","lines":[" "],"id":1719}],[{"start":{"row":505,"column":3},"end":{"row":505,"column":20},"action":"insert","lines":["(p->value != val)"],"id":1720}],[{"start":{"row":505,"column":20},"end":{"row":505,"column":21},"action":"insert","lines":["{"],"id":1721}],[{"start":{"row":513,"column":1},"end":{"row":514,"column":0},"action":"insert","lines":["",""],"id":1722}],[{"start":{"row":514,"column":0},"end":{"row":515,"column":0},"action":"insert","lines":["",""],"id":1723}],[{"start":{"row":515,"column":0},"end":{"row":515,"column":1},"action":"insert","lines":["e"],"id":1724}],[{"start":{"row":515,"column":1},"end":{"row":515,"column":2},"action":"insert","lines":["l"],"id":1725}],[{"start":{"row":515,"column":2},"end":{"row":515,"column":3},"action":"insert","lines":["s"],"id":1726}],[{"start":{"row":515,"column":3},"end":{"row":515,"column":4},"action":"insert","lines":["r"],"id":1727}],[{"start":{"row":515,"column":3},"end":{"row":515,"column":4},"action":"remove","lines":["r"],"id":1728}],[{"start":{"row":515,"column":3},"end":{"row":515,"column":4},"action":"insert","lines":["e"],"id":1729}],[{"start":{"row":515,"column":4},"end":{"row":515,"column":5},"action":"insert","lines":["}"],"id":1730}],[{"start":{"row":515,"column":4},"end":{"row":517,"column":0},"action":"insert","lines":["","\t",""],"id":1731}],[{"start":{"row":515,"column":4},"end":{"row":516,"column":0},"action":"insert","lines":["",""],"id":1732}],[{"start":{"row":516,"column":0},"end":{"row":516,"column":1},"action":"insert","lines":["f"],"id":1733}],[{"start":{"row":516,"column":1},"end":{"row":516,"column":2},"action":"insert","lines":["a"],"id":1734}],[{"start":{"row":516,"column":2},"end":{"row":516,"column":3},"action":"insert","lines":["l"],"id":1735}],[{"start":{"row":516,"column":3},"end":{"row":516,"column":4},"action":"insert","lines":["s"],"id":1736}],[{"start":{"row":516,"column":4},"end":{"row":516,"column":5},"action":"insert","lines":["e"],"id":1737}],[{"start":{"row":516,"column":5},"end":{"row":517,"column":0},"action":"insert","lines":["",""],"id":1738}],[{"start":{"row":503,"column":20},"end":{"row":504,"column":0},"action":"insert","lines":["",""],"id":1739},{"start":{"row":504,"column":0},"end":{"row":504,"column":8},"action":"insert","lines":["        "]}],[{"start":{"row":504,"column":8},"end":{"row":504,"column":9},"action":"insert","lines":["p"],"id":1740}],[{"start":{"row":504,"column":9},"end":{"row":504,"column":10},"action":"insert","lines":["o"],"id":1741}],[{"start":{"row":504,"column":10},"end":{"row":504,"column":11},"action":"insert","lines":["s"],"id":1742}],[{"start":{"row":504,"column":11},"end":{"row":504,"column":12},"action":"insert","lines":["+"],"id":1743}],[{"start":{"row":504,"column":12},"end":{"row":504,"column":13},"action":"insert","lines":["+"],"id":1744}],[{"start":{"row":502,"column":26},"end":{"row":502,"column":27},"action":"insert","lines":[" "],"id":1745}],[{"start":{"row":502,"column":27},"end":{"row":502,"column":28},"action":"insert","lines":["!"],"id":1746}],[{"start":{"row":502,"column":28},"end":{"row":502,"column":29},"action":"insert","lines":["!"],"id":1747}],[{"start":{"row":502,"column":28},"end":{"row":502,"column":29},"action":"remove","lines":["!"],"id":1748}],[{"start":{"row":502,"column":27},"end":{"row":502,"column":28},"action":"remove","lines":["!"],"id":1749}],[{"start":{"row":502,"column":27},"end":{"row":502,"column":28},"action":"insert","lines":["|"],"id":1750}],[{"start":{"row":502,"column":28},"end":{"row":502,"column":29},"action":"insert","lines":["|"],"id":1751}],[{"start":{"row":502,"column":29},"end":{"row":502,"column":30},"action":"insert","lines":[" "],"id":1752}],[{"start":{"row":502,"column":30},"end":{"row":502,"column":31},"action":"insert","lines":["p"],"id":1753}],[{"start":{"row":502,"column":31},"end":{"row":502,"column":32},"action":"insert","lines":["o"],"id":1754}],[{"start":{"row":502,"column":32},"end":{"row":502,"column":33},"action":"insert","lines":["s"],"id":1755}],[{"start":{"row":502,"column":33},"end":{"row":502,"column":34},"action":"insert","lines":[">"],"id":1756}],[{"start":{"row":502,"column":34},"end":{"row":502,"column":35},"action":"insert","lines":["s"],"id":1757}],[{"start":{"row":502,"column":35},"end":{"row":502,"column":36},"action":"insert","lines":["i"],"id":1758}],[{"start":{"row":502,"column":34},"end":{"row":502,"column":36},"action":"remove","lines":["si"],"id":1759},{"start":{"row":502,"column":34},"end":{"row":502,"column":38},"action":"insert","lines":["size"]}],[{"start":{"row":516,"column":4},"end":{"row":516,"column":5},"action":"insert","lines":["{"],"id":1760}],[{"start":{"row":518,"column":0},"end":{"row":518,"column":1},"action":"insert","lines":["}"],"id":1761}],[{"start":{"row":517,"column":5},"end":{"row":517,"column":6},"action":"insert","lines":[";"],"id":1762}],[{"start":{"row":504,"column":13},"end":{"row":504,"column":14},"action":"insert","lines":[";"],"id":1763}],[{"start":{"row":502,"column":26},"end":{"row":502,"column":39},"action":"remove","lines":[" || pos>size)"],"id":1764}],[{"start":{"row":504,"column":0},"end":{"row":505,"column":0},"action":"remove","lines":["        pos++;",""],"id":1765}],[{"start":{"row":500,"column":0},"end":{"row":501,"column":0},"action":"remove","lines":["    int pos = 0;",""],"id":1766}],[{"start":{"row":504,"column":0},"end":{"row":504,"column":21},"action":"remove","lines":["if (p->value != val){"],"id":1767}],[{"start":{"row":512,"column":1},"end":{"row":513,"column":0},"action":"remove","lines":["",""],"id":1768}],[{"start":{"row":512,"column":0},"end":{"row":512,"column":1},"action":"remove","lines":["}"],"id":1769}],[{"start":{"row":505,"column":4},"end":{"row":506,"column":0},"action":"insert","lines":["",""],"id":1770},{"start":{"row":506,"column":0},"end":{"row":506,"column":4},"action":"insert","lines":["    "]}],[{"start":{"row":505,"column":4},"end":{"row":505,"column":5},"action":"insert","lines":["i"],"id":1771}],[{"start":{"row":505,"column":4},"end":{"row":505,"column":5},"action":"remove","lines":["i"],"id":1772}],[{"start":{"row":502,"column":20},"end":{"row":503,"column":0},"action":"insert","lines":["",""],"id":1773},{"start":{"row":503,"column":0},"end":{"row":503,"column":8},"action":"insert","lines":["        "]}],[{"start":{"row":503,"column":8},"end":{"row":503,"column":9},"action":"insert","lines":["p"],"id":1774}],[{"start":{"row":503,"column":9},"end":{"row":503,"column":10},"action":"insert","lines":["o"],"id":1775}],[{"start":{"row":503,"column":10},"end":{"row":503,"column":11},"action":"insert","lines":["s"],"id":1776}],[{"start":{"row":503,"column":11},"end":{"row":503,"column":12},"action":"insert","lines":["s"],"id":1777}],[{"start":{"row":503,"column":11},"end":{"row":503,"column":12},"action":"remove","lines":["s"],"id":1778}],[{"start":{"row":503,"column":11},"end":{"row":503,"column":12},"action":"insert","lines":["+"],"id":1779}],[{"start":{"row":503,"column":12},"end":{"row":503,"column":13},"action":"insert","lines":["+"],"id":1780}],[{"start":{"row":499,"column":13},"end":{"row":500,"column":0},"action":"remove","lines":["",""],"id":1781}],[{"start":{"row":499,"column":13},"end":{"row":500,"column":0},"action":"insert","lines":["",""],"id":1782},{"start":{"row":500,"column":0},"end":{"row":500,"column":4},"action":"insert","lines":["    "]}],[{"start":{"row":500,"column":4},"end":{"row":500,"column":5},"action":"insert","lines":["i"],"id":1783}],[{"start":{"row":500,"column":5},"end":{"row":500,"column":6},"action":"insert","lines":["n"],"id":1784}],[{"start":{"row":500,"column":6},"end":{"row":500,"column":7},"action":"insert","lines":["i"],"id":1785}],[{"start":{"row":500,"column":6},"end":{"row":500,"column":7},"action":"remove","lines":["i"],"id":1786}],[{"start":{"row":500,"column":6},"end":{"row":500,"column":7},"action":"insert","lines":["t"],"id":1787}],[{"start":{"row":500,"column":7},"end":{"row":500,"column":8},"action":"insert","lines":[" "],"id":1788}],[{"start":{"row":500,"column":8},"end":{"row":500,"column":9},"action":"insert","lines":["p"],"id":1789}],[{"start":{"row":500,"column":9},"end":{"row":500,"column":10},"action":"insert","lines":["o"],"id":1790}],[{"start":{"row":500,"column":10},"end":{"row":500,"column":11},"action":"insert","lines":["s"],"id":1791}],[{"start":{"row":500,"column":11},"end":{"row":500,"column":12},"action":"insert","lines":["="],"id":1792}],[{"start":{"row":500,"column":12},"end":{"row":500,"column":13},"action":"insert","lines":["0"],"id":1793}],[{"start":{"row":501,"column":26},"end":{"row":501,"column":27},"action":"insert","lines":[" "],"id":1794}],[{"start":{"row":501,"column":26},"end":{"row":501,"column":27},"action":"remove","lines":[" "],"id":1795}],[{"start":{"row":501,"column":26},"end":{"row":501,"column":27},"action":"insert","lines":[" "],"id":1796}],[{"start":{"row":498,"column":4},"end":{"row":517,"column":1},"action":"remove","lines":["Link<T> *p, *q;","    p = head;","    int pos=0","    while((p->value != val  ){","        p = p->next;","        pos++","    }","","    ","    q = p->next;","    val = q->value;","    p->next = p->next->next;","","    delete q;","    size--;","\treturn true;","","else{","false;","}"],"id":1797},{"start":{"row":498,"column":4},"end":{"row":515,"column":0},"action":"insert","lines":[" Link<T> *p, *q;","    int pos = 0;","    p = head;","","    while(pos < size-1){","        q = p->next;","        if(q->value == val){","            p->next = p->next->next;","            delete q;","            size--;","            return true;","        }","        pos++;","        p = p->next;","    }","","\treturn false;",""]}],[{"start":{"row":521,"column":0},"end":{"row":522,"column":0},"action":"remove","lines":["\treturn false;",""],"id":1798},{"start":{"row":521,"column":0},"end":{"row":538,"column":0},"action":"insert","lines":[" Link<T> *p, *q;","    int pos = 0;","    p = head;","","    while(pos < size-1){","        q = p->next;","        if(q->value == val){","            p->next = p->next->next;","            delete q;","            size--;","            return true;","        }","        pos++;","        p = p->next;","    }","","\treturn false;",""]}],[{"start":{"row":521,"column":1},"end":{"row":537,"column":14},"action":"remove","lines":["Link<T> *p, *q;","    int pos = 0;","    p = head;","","    while(pos < size-1){","        q = p->next;","        if(q->value == val){","            p->next = p->next->next;","            delete q;","            size--;","            return true;","        }","        pos++;","        p = p->next;","    }","","\treturn false;"],"id":1799,"ignore":true}],[{"start":{"row":521,"column":1},"end":{"row":548,"column":5},"action":"insert","lines":["Link<T> *p, *q, *temp;","    int pos = 0;","    p = head;","    temp = 0;","","    if(empty()){","        return false;","    }","","    while(pos < size-1){","        q = p->next;","        if(q->value == val){","            temp = p;","        }","        pos++;","        p = p->next;","    }","","    if(temp){","        p = temp;","        p->next = p->next->next;","        temp = temp->next;","        delete temp;","        size--;","        return true;","    }else{","        return false;","    }"],"id":1800,"ignore":true}],[{"start":{"row":549,"column":1},"end":{"row":549,"column":3},"action":"insert","lines":[" :"],"id":1801,"ignore":true}],[{"start":{"row":549,"column":3},"end":{"row":549,"column":4},"action":"insert","lines":["D"],"id":1802,"ignore":true}],[{"start":{"row":549,"column":2},"end":{"row":549,"column":4},"action":"insert","lines":["//"],"id":1803,"ignore":true}],[{"start":{"row":0,"column":0},"end":{"row":634,"column":0},"action":"remove","lines":["/*"," * linkedlist.h"," *"," *  Created on: 05/08/2015"," *      Author: pperezm"," */","","#ifndef LINKEDLIST_H_","#define LINKEDLIST_H_","","#include <string>","#include <sstream>","#include \"exception.h\"","","template <class T> class List;","template <class T> class ListIterator;","","template <class T>","class Link {","private:","\tLink(T);","\tLink(T, Link<T>*);","\tLink(const Link<T>&);","","\tT\t    value;","\tLink<T> *next;","","\tfriend class List<T>;","\tfriend class ListIterator<T>;","};","","template <class T>","Link<T>::Link(T val) : value(val), next(0) {}","","template <class T>","Link<T>::Link(T val, Link* nxt) : value(val), next(nxt) {}","","template <class T>","Link<T>::Link(const Link<T> &source) : value(source.value), next(source.next) {}","","template <class T>","class List {","public:","\tList();","\tList(const List<T>&) throw (OutOfMemory);","\t~List();","","\tvoid addFirst(T) throw (OutOfMemory);","\tvoid add(T) throw (OutOfMemory);","\tT    getFirst() const throw (NoSuchElement);","\tT    removeFirst() throw (NoSuchElement);","\tint  length() const;","\tT    get(int) const throw (IndexOutOfBounds, NoSuchElement);","\tbool contains(T) const;","\tbool empty() const;","\tvoid clear();","\tstd::string toString() const;","\tvoid operator= (const List&) throw (OutOfMemory);","","\tvoid addBefore(ListIterator<T>&, T) throw (IllegalAction, OutOfMemory);","\tvoid addAfter(ListIterator<T>&, T) throw (IllegalAction, OutOfMemory);","\tT    removeCurrent(ListIterator<T>&) throw (IllegalAction);","","\tbool set(int, T) throw (IndexOutOfBounds);","\tint  indexOf(T) const;","\tint  lastIndexOf(T) const;","\tT    remove(int) throw (IndexOutOfBounds);","\tbool removeFirstOcurrence(T);","\tbool removeLastOcurrence(T);","","private:","\tLink<T> *head;","\tint \tsize;","","\tfriend class ListIterator<T>;","};","","template <class T>","List<T>::List() : head(0), size(0) {}","","template <class T>","List<T>::~List() {","\tclear();","}","","template <class T>","bool List<T>::empty() const {","\treturn (head == 0);","}","","template <class T>","int List<T>::length() const {","\treturn size;","}","","template <class T>","bool List<T>::contains(T val) const {","\tLink<T> *p;","","\tp = head;","\twhile (p != 0) {","\t\tif (p->value == val) {","\t\t\treturn true;","\t\t}","\t\tp = p->next;","\t}","\treturn false;","}","","template <class T>","T List<T>::getFirst() const throw (NoSuchElement) {","\tif (empty()) {","\t\tthrow NoSuchElement();","\t}","\treturn head->value;","}","","template <class T>","void List<T>::addFirst(T val) throw (OutOfMemory) {","\tLink<T> *newLink;","","\tnewLink = new Link<T>(val);","\tif (newLink == 0) {","\t\tthrow OutOfMemory();","\t}","\tnewLink->next = head;","\thead = newLink;","\tsize++;","}","","template <class T>","void List<T>::add(T val) throw (OutOfMemory) {","\tLink<T> *newLink, *p;","","\tnewLink = new Link<T>(val);","\tif (newLink == 0) {","\t\tthrow OutOfMemory();","\t}","\t","\tif (empty()) {","\t\taddFirst(val);","\t\treturn;","\t}","","\tp = head;","\twhile (p->next != 0) {","\t\tp = p->next;","\t}","","\tnewLink->next = 0;","\tp->next = newLink;","\tsize++;","}","","template <class T>","T List<T>::removeFirst() throw (NoSuchElement) {","\tT val;","\tLink<T> *p;","","\tif (empty()) {","\t\tthrow NoSuchElement();","\t}","","\tp = head;","","\thead = p->next;","\tval = p->value;","","\tdelete p;","\tsize--;","","\treturn val;","}","","template <class T>","T List<T>::get(int index) const throw (IndexOutOfBounds, NoSuchElement) {","\tint pos;","\tLink<T> *p;","","\tif (index < 0 || index >= size) {","\t\tthrow IndexOutOfBounds();","\t}","","\tif (index == 0) {","\t\treturn getFirst();","\t}","","\tp = head;","\tpos = 0;","\twhile (pos != index) {","\t\tp = p->next;","\t\tpos++;","\t}","","\treturn p->value;","}","","template <class T>","void List<T>::clear() {","\tLink<T> *p, *q;","","\tp = head;","\twhile (p != 0) {","\t\tq = p->next;","\t\tdelete p;","\t\tp = q;","\t}","\thead = 0;","\tsize = 0;","}","","template <class T>","std::string List<T>::toString() const {","\tstd::stringstream aux;","\tLink<T> *p;","","\tp = head;","\taux << \"[\";","\twhile (p != 0) {","\t\taux << p->value;","\t\tif (p->next != 0) {","\t\t\taux << \", \";","\t\t}","\t\tp = p->next;","\t}","\taux << \"]\";","\treturn aux.str();","}","","template <class T>","List<T>::List(const List<T> &source) throw (OutOfMemory) {","\tLink<T> *p, *q;","","\tif (source.empty()) {","\t\tsize = 0;","\t\thead = 0;","\t} else {","\t\tp = source.head;","\t\thead = new Link<T>(p->value);","\t\tif (head == 0) {","\t\t\tthrow OutOfMemory();","\t\t}","\t\tq = head;","","\t\tp = p->next;","\t\twhile(p != 0) {","\t\t\tq->next = new Link<T>(p->value);","\t\t\tif (q->next == 0) {","\t\t\t\tthrow OutOfMemory();","\t\t\t}","\t\t\tp = p->next;","\t\t\tq = q->next;","\t\t}","\t\tsize = source.size;","\t}","}","","template <class T>","void List<T>::operator=(const List<T> &source) throw (OutOfMemory) {","\tLink<T> *p, *q;","","\tclear();","\tif (source.empty()) {","\t\tsize = 0;","\t\thead = 0;","\t} else {","\t\tp = source.head;","\t\thead = new Link<T>(p->value);","\t\tif (head == 0) {","\t\t\tthrow OutOfMemory();","\t\t}","\t\tq = head;","","\t\tp = p->next;","\t\twhile(p != 0) {","\t\t\tq->next = new Link<T>(p->value);","\t\t\tif (q->next == 0) {","\t\t\t\tthrow OutOfMemory();","\t\t\t}","\t\t\tp = p->next;","\t\t\tq = q->next;","\t\t}","\t\tsize = source.size;","\t}","}","","template <class T>","void List<T>::addBefore(ListIterator<T> &itr, T val) throw (IllegalAction, OutOfMemory) {","\tLink<T> *newLink;","","\tif (this != itr.theList) {","\t\tthrow IllegalAction();","\t}","","\tnewLink = new Link<T>(val);","\tif (newLink == 0) {","\t\tthrow OutOfMemory();","\t}","","\t// between","\tif (itr.previous != 0) {","\t\tnewLink->next = itr.current;","\t\titr.previous->next = newLink;","\t\titr.previous = itr.previous->next;","\t\tsize++;","\t// start","\t} else {","\t\taddFirst(val);","\t\titr.previous = head;","\t\titr.current = itr.previous->next;","\t}","}","","template <class T>","void List<T>::addAfter(ListIterator<T> &itr, T val) throw (IllegalAction, OutOfMemory) {","\tLink<T> *newLink;","","\tif (this != itr.theList) {","\t\tthrow IllegalAction();","\t}","","\tnewLink = new Link<T>(val);","\tif (newLink == 0) {","\t\tthrow OutOfMemory();","\t}","","","\t// between","\tif (itr.current != 0) {","\t\tnewLink->next = itr.current->next;","\t\titr.current->next = newLink;","\t\tsize++;","\t// end","\t} else if (itr.previous != 0) {","\t\titr.previous->next = newLink;","\t\titr.current = newLink;","\t\tsize++;","\t// start","\t} else {","\t\taddFirst(val);","\t\titr.current = head;","\t\titr.previous = 0;","\t}","}","","template <class T>","T List<T>::removeCurrent(ListIterator<T> &itr) throw (IllegalAction) {","\tT val;","","\tif (this != itr.theList) {","\t\tthrow IllegalAction();","\t}","","\tif (itr.current == 0) {","\t\tthrow NoSuchElement();","\t}","","\tif (itr.previous == 0) {","\t\thead = itr.current->next;","\t} else {","\t\titr.previous->next = itr.current->next;","\t}","","\tval = itr.current->value;","\tdelete itr.current;","\titr.current = 0;","","\t//std::cout << \"remove current = \" << ((itr.current != 0)? itr.current->value : 0) << \" previous: \" << ((itr.previous != 0)? itr.previous->value : 0) << std::endl;","\treturn val;","}","","template <class T>","bool List<T>::set(int index, T val) throw (IndexOutOfBounds) {","if (index>=size){","\tthrow IndexOutOfBounds();","}","if (index<0){","\tthrow IndexOutOfBounds();","}","\tLink<T> *uno;","\tuno=head;","\tint i=0;","\twhile (i<index){","\tuno=uno->next;","\ti++;","\t\t","\t}","\tuno->value=val;","\treturn true;","\t","\t","","}","","template <class T>","int List<T>::indexOf(T val) const {","\tLink<T> *uno;","\tuno=head;","\tint i=0;","\t","\twhile (uno->value!=val){","\tuno=uno->next;","\ti++;","\t\t","\t}","\treturn \ti;","","\t","\t","}","","template <class T>","int List<T>::lastIndexOf(T val) const {","/*\t","\tLink<T> *uno;","\tuno=head;","\tint index=0;","\tint lugar=0;","\tint i=0;","\t","\twhile (uno->value!=val){","\tuno=uno->next;","\ti++;","\t\t","\t}","\treturn \ti;","*/","  int pos = 0;","  int lastIndex = -1;","    Link<T> *p;","    p = head;","","    while(pos < size){","        if(p->value == val){","            lastIndex = pos;","        }","        pos++;","        p = p->next;","    }","","    return lastIndex;","\t","\t","","","\t","}","","template <class T>","T List<T>::remove(int index) throw (IndexOutOfBounds) {","","if (index>=size){","\tthrow IndexOutOfBounds();","}","if (index<0){","\tthrow IndexOutOfBounds();","}","\t","\t/*","\tLink<T> *uno;","\tuno=head;","\tint i=0;","\twhile (i<index-1){","\tuno=uno->next;","\ti++;","\t\t","\t}","\tuno->next=uno->next->next;","\tsize--;","\tdelete uno->n","\t","\t*/","\t","\tT val;","    Link<T> *p, *q;","    p = head;","    int pos = 0;","","    while((pos != index-1) && pos < size){","        p = p->next;","        pos++;","    }","","    q = p->next;","    val = q->value;","    p->next = p->next->next;","","    delete q;","    size--;","\treturn val;","\t","","","\t","}","","template <class T>","bool List<T>::removeFirstOcurrence(T val) {","     Link<T> *p, *q;","    int pos = 0;","    p = head;","","    while(pos < size-1){","        q = p->next;","        if(q->value == val){","            p->next = p->next->next;","            delete q;","            size--;","            return true;","        }","        pos++;","        p = p->next;","    }","","\treturn false;","","\t","}","","template <class T>","bool List<T>::removeLastOcurrence(T val) {"," Link<T> *p, *q, *temp;","    int pos = 0;","    p = head;","    temp = 0;","","    if(empty()){","        return false;","    }","","    while(pos < size-1){","        q = p->next;","        if(q->value == val){","            temp = p;","        }","        pos++;","        p = p->next;","    }","","    if(temp){","        p = temp;","        p->next = p->next->next;","        temp = temp->next;","        delete temp;","        size--;","        return true;","    }else{","        return false;","    }","} //:D","","","","//clase iterador","template <class T>","class ListIterator {","public:","\tListIterator(List<T>*);","\tListIterator(const ListIterator<T>&);","","\tbool begin();","\tbool end();","\tT&   operator() () throw (NoSuchElement);","\tbool operator++ ();","\tvoid operator= (T) throw (NoSuchElement);","","private:","\tLink<T> *current;","\tLink<T> *previous;","\tList<T> *theList;","","\tfriend class List<T>;","};","","template <class T>","ListIterator<T>::ListIterator(List<T> *aList) : theList(aList) {","\tbegin();","}","","template <class T>","ListIterator<T>::ListIterator(const ListIterator<T> &source) : theList(source.theList) {","\tbegin();","}","","template <class T>","bool ListIterator<T>::begin() {","\tprevious = 0;","\tcurrent = theList->head;","\treturn (current != 0);","}","","template <class T>","T& ListIterator<T>::operator() () throw (NoSuchElement) {","\tif (current == 0) {","\t\tthrow NoSuchElement();","\t}","\treturn current->value;","}","","template <class T>","bool ListIterator<T>::end() {","\t//std::cout << \"1 end current = \" << ((current != 0)? current->value : 0) << \" previous: \" << ((previous != 0)? previous->value : 0) << std::endl;","\tif (current == 0) {","\t\tif (previous != 0) {","\t\t\tcurrent = previous->next;","\t\t}","\t}","\treturn (current == 0);","}","","template <class T>","bool ListIterator<T>::operator++ () {","\tif (current == 0) {","\t\tif (previous == 0) {","\t\t\tcurrent = theList->head;","\t\t} else {","\t\t\tcurrent = previous->next;","\t\t}","\t} else {","\t\tprevious = current;","\t\tcurrent = current->next;","\t}","\treturn (current != 0);","}","","template <class T>","void ListIterator<T>::operator= (T val) throw (NoSuchElement) {","\tif (current == 0) {","\t\tthrow NoSuchElement();","\t}","\tcurrent->value = val;","}","","#endif /* LINKEDLIST_H_ */",""],"id":1804},{"start":{"row":0,"column":0},"end":{"row":598,"column":0},"action":"insert","lines":["/*"," * linkedlist.h"," *"," *  Created on: 05/08/2015"," *      Author: pperezm"," */","","#ifndef LINKEDLIST_H_","#define LINKEDLIST_H_","","#include <string>","#include <sstream>","#include \"exception.h\"","","template <class T> class List;","template <class T> class ListIterator;","","template <class T>","class Link {","private:","\tLink(T);","\tLink(T, Link<T>*);","\tLink(const Link<T>&);","","\tT\t    value;","\tLink<T> *next;","","\tfriend class List<T>;","\tfriend class ListIterator<T>;","};","","template <class T>","Link<T>::Link(T val) : value(val), next(0) {}","","template <class T>","Link<T>::Link(T val, Link* nxt) : value(val), next(nxt) {}","","template <class T>","Link<T>::Link(const Link<T> &source) : value(source.value), next(source.next) {}","","template <class T>","class List {","public:","\tList();","\tList(const List<T>&) throw (OutOfMemory);","\t~List();","","\tvoid addFirst(T) throw (OutOfMemory);","\tvoid add(T) throw (OutOfMemory);","\tT    getFirst() const throw (NoSuchElement);","\tT    removeFirst() throw (NoSuchElement);","\tint  length() const;","\tT    get(int) const throw (IndexOutOfBounds, NoSuchElement);","\tbool contains(T) const;","\tbool empty() const;","\tvoid clear();","\tstd::string toString() const;","\tvoid operator= (const List&) throw (OutOfMemory);","","\tvoid addBefore(ListIterator<T>&, T) throw (IllegalAction, OutOfMemory);","\tvoid addAfter(ListIterator<T>&, T) throw (IllegalAction, OutOfMemory);","\tT    removeCurrent(ListIterator<T>&) throw (IllegalAction);","","\tbool set(int, T) throw (IndexOutOfBounds);","\tint  indexOf(T) const;","\tint  lastIndexOf(T) const;","\tT    remove(int) throw (IndexOutOfBounds);","\tbool removeFirstOcurrence(T);","\tbool removeLastOcurrence(T);","","private:","\tLink<T> *head;","\tint \tsize;","","\tfriend class ListIterator<T>;","};","","template <class T>","List<T>::List() : head(0), size(0) {}","","template <class T>","List<T>::~List() {","\tclear();","}","","template <class T>","bool List<T>::empty() const {","\treturn (head == 0);","}","","template <class T>","int List<T>::length() const {","\treturn size;","}","","template <class T>","bool List<T>::contains(T val) const {","\tLink<T> *p;","","\tp = head;","\twhile (p != 0) {","\t\tif (p->value == val) {","\t\t\treturn true;","\t\t}","\t\tp = p->next;","\t}","\treturn false;","}","","template <class T>","T List<T>::getFirst() const throw (NoSuchElement) {","\tif (empty()) {","\t\tthrow NoSuchElement();","\t}","\treturn head->value;","}","","template <class T>","void List<T>::addFirst(T val) throw (OutOfMemory) {","\tLink<T> *newLink;","","\tnewLink = new Link<T>(val);","\tif (newLink == 0) {","\t\tthrow OutOfMemory();","\t}","\tnewLink->next = head;","\thead = newLink;","\tsize++;","}","","template <class T>","void List<T>::add(T val) throw (OutOfMemory) {","\tLink<T> *newLink, *p;","","\tnewLink = new Link<T>(val);","\tif (newLink == 0) {","\t\tthrow OutOfMemory();","\t}","\t","\tif (empty()) {","\t\taddFirst(val);","\t\treturn;","\t}","","\tp = head;","\twhile (p->next != 0) {","\t\tp = p->next;","\t}","","\tnewLink->next = 0;","\tp->next = newLink;","\tsize++;","}","","template <class T>","T List<T>::removeFirst() throw (NoSuchElement) {","\tT val;","\tLink<T> *p;","","\tif (empty()) {","\t\tthrow NoSuchElement();","\t}","","\tp = head;","","\thead = p->next;","\tval = p->value;","","\tdelete p;","\tsize--;","","\treturn val;","}","","template <class T>","T List<T>::get(int index) const throw (IndexOutOfBounds, NoSuchElement) {","\tint pos;","\tLink<T> *p;","","\tif (index < 0 || index >= size) {","\t\tthrow IndexOutOfBounds();","\t}","","\tif (index == 0) {","\t\treturn getFirst();","\t}","","\tp = head;","\tpos = 0;","\twhile (pos != index) {","\t\tp = p->next;","\t\tpos++;","\t}","","\treturn p->value;","}","","template <class T>","void List<T>::clear() {","\tLink<T> *p, *q;","","\tp = head;","\twhile (p != 0) {","\t\tq = p->next;","\t\tdelete p;","\t\tp = q;","\t}","\thead = 0;","\tsize = 0;","}","","template <class T>","std::string List<T>::toString() const {","\tstd::stringstream aux;","\tLink<T> *p;","","\tp = head;","\taux << \"[\";","\twhile (p != 0) {","\t\taux << p->value;","\t\tif (p->next != 0) {","\t\t\taux << \", \";","\t\t}","\t\tp = p->next;","\t}","\taux << \"]\";","\treturn aux.str();","}","","template <class T>","List<T>::List(const List<T> &source) throw (OutOfMemory) {","\tLink<T> *p, *q;","","\tif (source.empty()) {","\t\tsize = 0;","\t\thead = 0;","\t} else {","\t\tp = source.head;","\t\thead = new Link<T>(p->value);","\t\tif (head == 0) {","\t\t\tthrow OutOfMemory();","\t\t}","\t\tq = head;","","\t\tp = p->next;","\t\twhile(p != 0) {","\t\t\tq->next = new Link<T>(p->value);","\t\t\tif (q->next == 0) {","\t\t\t\tthrow OutOfMemory();","\t\t\t}","\t\t\tp = p->next;","\t\t\tq = q->next;","\t\t}","\t\tsize = source.size;","\t}","}","","template <class T>","void List<T>::operator=(const List<T> &source) throw (OutOfMemory) {","\tLink<T> *p, *q;","","\tclear();","\tif (source.empty()) {","\t\tsize = 0;","\t\thead = 0;","\t} else {","\t\tp = source.head;","\t\thead = new Link<T>(p->value);","\t\tif (head == 0) {","\t\t\tthrow OutOfMemory();","\t\t}","\t\tq = head;","","\t\tp = p->next;","\t\twhile(p != 0) {","\t\t\tq->next = new Link<T>(p->value);","\t\t\tif (q->next == 0) {","\t\t\t\tthrow OutOfMemory();","\t\t\t}","\t\t\tp = p->next;","\t\t\tq = q->next;","\t\t}","\t\tsize = source.size;","\t}","}","","template <class T>","void List<T>::addBefore(ListIterator<T> &itr, T val) throw (IllegalAction, OutOfMemory) {","\tLink<T> *newLink;","","\tif (this != itr.theList) {","\t\tthrow IllegalAction();","\t}","","\tnewLink = new Link<T>(val);","\tif (newLink == 0) {","\t\tthrow OutOfMemory();","\t}","","\t// between","\tif (itr.previous != 0) {","\t\tnewLink->next = itr.current;","\t\titr.previous->next = newLink;","\t\titr.previous = itr.previous->next;","\t\tsize++;","\t// start","\t} else {","\t\taddFirst(val);","\t\titr.previous = head;","\t\titr.current = itr.previous->next;","\t}","}","","template <class T>","void List<T>::addAfter(ListIterator<T> &itr, T val) throw (IllegalAction, OutOfMemory) {","\tLink<T> *newLink;","","\tif (this != itr.theList) {","\t\tthrow IllegalAction();","\t}","","\tnewLink = new Link<T>(val);","\tif (newLink == 0) {","\t\tthrow OutOfMemory();","\t}","","","\t// between","\tif (itr.current != 0) {","\t\tnewLink->next = itr.current->next;","\t\titr.current->next = newLink;","\t\tsize++;","\t// end","\t} else if (itr.previous != 0) {","\t\titr.previous->next = newLink;","\t\titr.current = newLink;","\t\tsize++;","\t// start","\t} else {","\t\taddFirst(val);","\t\titr.current = head;","\t\titr.previous = 0;","\t}","}","","template <class T>","T List<T>::removeCurrent(ListIterator<T> &itr) throw (IllegalAction) {","\tT val;","","\tif (this != itr.theList) {","\t\tthrow IllegalAction();","\t}","","\tif (itr.current == 0) {","\t\tthrow NoSuchElement();","\t}","","\tif (itr.previous == 0) {","\t\thead = itr.current->next;","\t} else {","\t\titr.previous->next = itr.current->next;","\t}","","\tval = itr.current->value;","\tdelete itr.current;","\titr.current = 0;","","\t//std::cout << \"remove current = \" << ((itr.current != 0)? itr.current->value : 0) << \" previous: \" << ((itr.previous != 0)? itr.previous->value : 0) << std::endl;","\treturn val;","}","","template <class T>","bool List<T>::set(int index, T val) throw (IndexOutOfBounds) {","if (index>=size){","\tthrow IndexOutOfBounds();","}","if (index<0){","\tthrow IndexOutOfBounds();","}","\tLink<T> *p;","\tp=head;","\tint i=0;","\twhile (i<index){","\tp=p->next;","\ti++;","\t\t","\t}","\tp->value=val;","\treturn true;","\t","\t","","}","","template <class T>","int List<T>::indexOf(T val) const {","\tLink<T> *p;","\tp=head;","\tint i=0;","\t","\twhile (p->value!=val){","\tp=p->next;","\ti++;","\t\t","\t}","\treturn \ti;","","\t","\t","}","","template <class T>","int List<T>::lastIndexOf(T val) const {","","  int i = 0;","  int ultimo = -1;","    Link<T> *p;","    p = head;","","    while( i < size){","        if(p->value == val){","            ultimo = i;","        }","        i++;","        p = p->next;","    }","","    return ultimo;","\t","\t","","","\t","}","","template <class T>","T List<T>::remove(int index) throw (IndexOutOfBounds) {","","if (index>=size){","\tthrow IndexOutOfBounds();","}","if (index<0){","\tthrow IndexOutOfBounds();","}","\t","    Link<T> *p;","    Link<T> *q;","    T val;","    p = head;","    int i = 0;","","    while((i != index-1)){","        p = p->next;","        i++;","    }","","    q = p->next;","    val = q->value;","    p->next = p->next->next;","","    delete q;","    size--;","\treturn val;","\t","","\t","}","","template <class T>","bool List<T>::removeFirstOcurrence(T val) {","  ","    Link<T> *p;","    Link<T> *q;","    int i = 0;","    p = head;","","    while(i < size-1){","        q = p->next;","        if(q->value == val){","            p->next = p->next->next;","            delete q;","            size--;","            return true;","        }","        i++;","        p = p->next;","    }","","\treturn false;","","\t","}","","template <class T>","bool List<T>::removeLastOcurrence(T val) {"," Link<T> *p;"," Link<T> *q;","    int i = 0;","    p = head;","","    while(i < size-1){","        q = p->next;","        if(q->value == val){","            p->next = p->next->next;","            delete q;","            size--;","            return true;","        }","        i++;","        p = p->next;","    }","","\treturn false;","}","","","","//clase iterador","template <class T>","class ListIterator {","public:","\tListIterator(List<T>*);","\tListIterator(const ListIterator<T>&);","","\tbool begin();","\tbool end();","\tT&   operator() () throw (NoSuchElement);","\tbool operator++ ();","\tvoid operator= (T) throw (NoSuchElement);","","private:","\tLink<T> *current;","\tLink<T> *previous;","\tList<T> *theList;","","\tfriend class List<T>;","};","","template <class T>","ListIterator<T>::ListIterator(List<T> *aList) : theList(aList) {","\tbegin();","}","","template <class T>","ListIterator<T>::ListIterator(const ListIterator<T> &source) : theList(source.theList) {","\tbegin();","}","","template <class T>","bool ListIterator<T>::begin() {","\tprevious = 0;","\tcurrent = theList->head;","\treturn (current != 0);","}","","template <class T>","T& ListIterator<T>::operator() () throw (NoSuchElement) {","\tif (current == 0) {","\t\tthrow NoSuchElement();","\t}","\treturn current->value;","}","","template <class T>","bool ListIterator<T>::end() {","\t//std::cout << \"1 end current = \" << ((current != 0)? current->value : 0) << \" previous: \" << ((previous != 0)? previous->value : 0) << std::endl;","\tif (current == 0) {","\t\tif (previous != 0) {","\t\t\tcurrent = previous->next;","\t\t}","\t}","\treturn (current == 0);","}","","template <class T>","bool ListIterator<T>::operator++ () {","\tif (current == 0) {","\t\tif (previous == 0) {","\t\t\tcurrent = theList->head;","\t\t} else {","\t\t\tcurrent = previous->next;","\t\t}","\t} else {","\t\tprevious = current;","\t\tcurrent = current->next;","\t}","\treturn (current != 0);","}","","template <class T>","void ListIterator<T>::operator= (T val) throw (NoSuchElement) {","\tif (current == 0) {","\t\tthrow NoSuchElement();","\t}","\tcurrent->value = val;","}","","#endif /* LINKEDLIST_H_ */",""]}],[{"start":{"row":0,"column":0},"end":{"row":598,"column":0},"action":"remove","lines":["/*"," * linkedlist.h"," *"," *  Created on: 05/08/2015"," *      Author: pperezm"," */","","#ifndef LINKEDLIST_H_","#define LINKEDLIST_H_","","#include <string>","#include <sstream>","#include \"exception.h\"","","template <class T> class List;","template <class T> class ListIterator;","","template <class T>","class Link {","private:","\tLink(T);","\tLink(T, Link<T>*);","\tLink(const Link<T>&);","","\tT\t    value;","\tLink<T> *next;","","\tfriend class List<T>;","\tfriend class ListIterator<T>;","};","","template <class T>","Link<T>::Link(T val) : value(val), next(0) {}","","template <class T>","Link<T>::Link(T val, Link* nxt) : value(val), next(nxt) {}","","template <class T>","Link<T>::Link(const Link<T> &source) : value(source.value), next(source.next) {}","","template <class T>","class List {","public:","\tList();","\tList(const List<T>&) throw (OutOfMemory);","\t~List();","","\tvoid addFirst(T) throw (OutOfMemory);","\tvoid add(T) throw (OutOfMemory);","\tT    getFirst() const throw (NoSuchElement);","\tT    removeFirst() throw (NoSuchElement);","\tint  length() const;","\tT    get(int) const throw (IndexOutOfBounds, NoSuchElement);","\tbool contains(T) const;","\tbool empty() const;","\tvoid clear();","\tstd::string toString() const;","\tvoid operator= (const List&) throw (OutOfMemory);","","\tvoid addBefore(ListIterator<T>&, T) throw (IllegalAction, OutOfMemory);","\tvoid addAfter(ListIterator<T>&, T) throw (IllegalAction, OutOfMemory);","\tT    removeCurrent(ListIterator<T>&) throw (IllegalAction);","","\tbool set(int, T) throw (IndexOutOfBounds);","\tint  indexOf(T) const;","\tint  lastIndexOf(T) const;","\tT    remove(int) throw (IndexOutOfBounds);","\tbool removeFirstOcurrence(T);","\tbool removeLastOcurrence(T);","","private:","\tLink<T> *head;","\tint \tsize;","","\tfriend class ListIterator<T>;","};","","template <class T>","List<T>::List() : head(0), size(0) {}","","template <class T>","List<T>::~List() {","\tclear();","}","","template <class T>","bool List<T>::empty() const {","\treturn (head == 0);","}","","template <class T>","int List<T>::length() const {","\treturn size;","}","","template <class T>","bool List<T>::contains(T val) const {","\tLink<T> *p;","","\tp = head;","\twhile (p != 0) {","\t\tif (p->value == val) {","\t\t\treturn true;","\t\t}","\t\tp = p->next;","\t}","\treturn false;","}","","template <class T>","T List<T>::getFirst() const throw (NoSuchElement) {","\tif (empty()) {","\t\tthrow NoSuchElement();","\t}","\treturn head->value;","}","","template <class T>","void List<T>::addFirst(T val) throw (OutOfMemory) {","\tLink<T> *newLink;","","\tnewLink = new Link<T>(val);","\tif (newLink == 0) {","\t\tthrow OutOfMemory();","\t}","\tnewLink->next = head;","\thead = newLink;","\tsize++;","}","","template <class T>","void List<T>::add(T val) throw (OutOfMemory) {","\tLink<T> *newLink, *p;","","\tnewLink = new Link<T>(val);","\tif (newLink == 0) {","\t\tthrow OutOfMemory();","\t}","\t","\tif (empty()) {","\t\taddFirst(val);","\t\treturn;","\t}","","\tp = head;","\twhile (p->next != 0) {","\t\tp = p->next;","\t}","","\tnewLink->next = 0;","\tp->next = newLink;","\tsize++;","}","","template <class T>","T List<T>::removeFirst() throw (NoSuchElement) {","\tT val;","\tLink<T> *p;","","\tif (empty()) {","\t\tthrow NoSuchElement();","\t}","","\tp = head;","","\thead = p->next;","\tval = p->value;","","\tdelete p;","\tsize--;","","\treturn val;","}","","template <class T>","T List<T>::get(int index) const throw (IndexOutOfBounds, NoSuchElement) {","\tint pos;","\tLink<T> *p;","","\tif (index < 0 || index >= size) {","\t\tthrow IndexOutOfBounds();","\t}","","\tif (index == 0) {","\t\treturn getFirst();","\t}","","\tp = head;","\tpos = 0;","\twhile (pos != index) {","\t\tp = p->next;","\t\tpos++;","\t}","","\treturn p->value;","}","","template <class T>","void List<T>::clear() {","\tLink<T> *p, *q;","","\tp = head;","\twhile (p != 0) {","\t\tq = p->next;","\t\tdelete p;","\t\tp = q;","\t}","\thead = 0;","\tsize = 0;","}","","template <class T>","std::string List<T>::toString() const {","\tstd::stringstream aux;","\tLink<T> *p;","","\tp = head;","\taux << \"[\";","\twhile (p != 0) {","\t\taux << p->value;","\t\tif (p->next != 0) {","\t\t\taux << \", \";","\t\t}","\t\tp = p->next;","\t}","\taux << \"]\";","\treturn aux.str();","}","","template <class T>","List<T>::List(const List<T> &source) throw (OutOfMemory) {","\tLink<T> *p, *q;","","\tif (source.empty()) {","\t\tsize = 0;","\t\thead = 0;","\t} else {","\t\tp = source.head;","\t\thead = new Link<T>(p->value);","\t\tif (head == 0) {","\t\t\tthrow OutOfMemory();","\t\t}","\t\tq = head;","","\t\tp = p->next;","\t\twhile(p != 0) {","\t\t\tq->next = new Link<T>(p->value);","\t\t\tif (q->next == 0) {","\t\t\t\tthrow OutOfMemory();","\t\t\t}","\t\t\tp = p->next;","\t\t\tq = q->next;","\t\t}","\t\tsize = source.size;","\t}","}","","template <class T>","void List<T>::operator=(const List<T> &source) throw (OutOfMemory) {","\tLink<T> *p, *q;","","\tclear();","\tif (source.empty()) {","\t\tsize = 0;","\t\thead = 0;","\t} else {","\t\tp = source.head;","\t\thead = new Link<T>(p->value);","\t\tif (head == 0) {","\t\t\tthrow OutOfMemory();","\t\t}","\t\tq = head;","","\t\tp = p->next;","\t\twhile(p != 0) {","\t\t\tq->next = new Link<T>(p->value);","\t\t\tif (q->next == 0) {","\t\t\t\tthrow OutOfMemory();","\t\t\t}","\t\t\tp = p->next;","\t\t\tq = q->next;","\t\t}","\t\tsize = source.size;","\t}","}","","template <class T>","void List<T>::addBefore(ListIterator<T> &itr, T val) throw (IllegalAction, OutOfMemory) {","\tLink<T> *newLink;","","\tif (this != itr.theList) {","\t\tthrow IllegalAction();","\t}","","\tnewLink = new Link<T>(val);","\tif (newLink == 0) {","\t\tthrow OutOfMemory();","\t}","","\t// between","\tif (itr.previous != 0) {","\t\tnewLink->next = itr.current;","\t\titr.previous->next = newLink;","\t\titr.previous = itr.previous->next;","\t\tsize++;","\t// start","\t} else {","\t\taddFirst(val);","\t\titr.previous = head;","\t\titr.current = itr.previous->next;","\t}","}","","template <class T>","void List<T>::addAfter(ListIterator<T> &itr, T val) throw (IllegalAction, OutOfMemory) {","\tLink<T> *newLink;","","\tif (this != itr.theList) {","\t\tthrow IllegalAction();","\t}","","\tnewLink = new Link<T>(val);","\tif (newLink == 0) {","\t\tthrow OutOfMemory();","\t}","","","\t// between","\tif (itr.current != 0) {","\t\tnewLink->next = itr.current->next;","\t\titr.current->next = newLink;","\t\tsize++;","\t// end","\t} else if (itr.previous != 0) {","\t\titr.previous->next = newLink;","\t\titr.current = newLink;","\t\tsize++;","\t// start","\t} else {","\t\taddFirst(val);","\t\titr.current = head;","\t\titr.previous = 0;","\t}","}","","template <class T>","T List<T>::removeCurrent(ListIterator<T> &itr) throw (IllegalAction) {","\tT val;","","\tif (this != itr.theList) {","\t\tthrow IllegalAction();","\t}","","\tif (itr.current == 0) {","\t\tthrow NoSuchElement();","\t}","","\tif (itr.previous == 0) {","\t\thead = itr.current->next;","\t} else {","\t\titr.previous->next = itr.current->next;","\t}","","\tval = itr.current->value;","\tdelete itr.current;","\titr.current = 0;","","\t//std::cout << \"remove current = \" << ((itr.current != 0)? itr.current->value : 0) << \" previous: \" << ((itr.previous != 0)? itr.previous->value : 0) << std::endl;","\treturn val;","}","","template <class T>","bool List<T>::set(int index, T val) throw (IndexOutOfBounds) {","if (index>=size){","\tthrow IndexOutOfBounds();","}","if (index<0){","\tthrow IndexOutOfBounds();","}","\tLink<T> *p;","\tp=head;","\tint i=0;","\twhile (i<index){","\tp=p->next;","\ti++;","\t\t","\t}","\tp->value=val;","\treturn true;","\t","\t","","}","","template <class T>","int List<T>::indexOf(T val) const {","\tLink<T> *p;","\tp=head;","\tint i=0;","\t","\twhile (p->value!=val){","\tp=p->next;","\ti++;","\t\t","\t}","\treturn \ti;","","\t","\t","}","","template <class T>","int List<T>::lastIndexOf(T val) const {","","  int i = 0;","  int ultimo = -1;","    Link<T> *p;","    p = head;","","    while( i < size){","        if(p->value == val){","            ultimo = i;","        }","        i++;","        p = p->next;","    }","","    return ultimo;","\t","\t","","","\t","}","","template <class T>","T List<T>::remove(int index) throw (IndexOutOfBounds) {","","if (index>=size){","\tthrow IndexOutOfBounds();","}","if (index<0){","\tthrow IndexOutOfBounds();","}","\t","    Link<T> *p;","    Link<T> *q;","    T val;","    p = head;","    int i = 0;","","    while((i != index-1)){","        p = p->next;","        i++;","    }","","    q = p->next;","    val = q->value;","    p->next = p->next->next;","","    delete q;","    size--;","\treturn val;","\t","","\t","}","","template <class T>","bool List<T>::removeFirstOcurrence(T val) {","  ","    Link<T> *p;","    Link<T> *q;","    int i = 0;","    p = head;","","    while(i < size-1){","        q = p->next;","        if(q->value == val){","            p->next = p->next->next;","            delete q;","            size--;","            return true;","        }","        i++;","        p = p->next;","    }","","\treturn false;","","\t","}","","template <class T>","bool List<T>::removeLastOcurrence(T val) {"," Link<T> *p;"," Link<T> *q;","    int i = 0;","    p = head;","","    while(i < size-1){","        q = p->next;","        if(q->value == val){","            p->next = p->next->next;","            delete q;","            size--;","            return true;","        }","        i++;","        p = p->next;","    }","","\treturn false;","}","","","","//clase iterador","template <class T>","class ListIterator {","public:","\tListIterator(List<T>*);","\tListIterator(const ListIterator<T>&);","","\tbool begin();","\tbool end();","\tT&   operator() () throw (NoSuchElement);","\tbool operator++ ();","\tvoid operator= (T) throw (NoSuchElement);","","private:","\tLink<T> *current;","\tLink<T> *previous;","\tList<T> *theList;","","\tfriend class List<T>;","};","","template <class T>","ListIterator<T>::ListIterator(List<T> *aList) : theList(aList) {","\tbegin();","}","","template <class T>","ListIterator<T>::ListIterator(const ListIterator<T> &source) : theList(source.theList) {","\tbegin();","}","","template <class T>","bool ListIterator<T>::begin() {","\tprevious = 0;","\tcurrent = theList->head;","\treturn (current != 0);","}","","template <class T>","T& ListIterator<T>::operator() () throw (NoSuchElement) {","\tif (current == 0) {","\t\tthrow NoSuchElement();","\t}","\treturn current->value;","}","","template <class T>","bool ListIterator<T>::end() {","\t//std::cout << \"1 end current = \" << ((current != 0)? current->value : 0) << \" previous: \" << ((previous != 0)? previous->value : 0) << std::endl;","\tif (current == 0) {","\t\tif (previous != 0) {","\t\t\tcurrent = previous->next;","\t\t}","\t}","\treturn (current == 0);","}","","template <class T>","bool ListIterator<T>::operator++ () {","\tif (current == 0) {","\t\tif (previous == 0) {","\t\t\tcurrent = theList->head;","\t\t} else {","\t\t\tcurrent = previous->next;","\t\t}","\t} else {","\t\tprevious = current;","\t\tcurrent = current->next;","\t}","\treturn (current != 0);","}","","template <class T>","void ListIterator<T>::operator= (T val) throw (NoSuchElement) {","\tif (current == 0) {","\t\tthrow NoSuchElement();","\t}","\tcurrent->value = val;","}","","#endif /* LINKEDLIST_H_ */",""],"id":1805},{"start":{"row":0,"column":0},"end":{"row":589,"column":26},"action":"insert","lines":["/*"," * linkedlist.h"," *"," *  Created on: 16/09/2016  "," *"," *  José Ramón Fernando Romero Chávez "," *  A01700318"," *"," */","","#ifndef LINKEDLIST_H_","#define LINKEDLIST_H_","#include <string>","#include <sstream>","#include \"exception.h\"","","template < class T > class List;","template < class T > class ListIterator;","","template < class T >","  class Link {","    private:","      Link(T);","    Link(T, Link < T > * );","    Link(const Link < T > & );","","    T value;","    Link < T > * next;","","    friend class List < T > ;","    friend class ListIterator < T > ;","  };","","template < class T >","  Link < T > ::Link(T val): value(val), next(0) {}","","template < class T >","  Link < T > ::Link(T val, Link * nxt): value(val), next(nxt) {}","","template < class T >","  Link < T > ::Link(const Link < T > & source): value(source.value), next(source.next) {}","","template < class T >","  class List {","    public:","      List();","    List(const List < T > & ) throw (OutOfMemory);","    ~List();","","    void addFirst(T) throw (OutOfMemory);","    void add(T) throw (OutOfMemory);","    T getFirst() const","    throw (NoSuchElement);","    T removeFirst() throw (NoSuchElement);","    int length() const;","    T get(int) const","    throw (IndexOutOfBounds, NoSuchElement);","    bool contains(T) const;","    bool empty() const;","    void clear();","    std::string toString() const;","    void operator = (const List & ) throw (OutOfMemory);","","    void addBefore(ListIterator < T > & , T) throw (IllegalAction, OutOfMemory);","    void addAfter(ListIterator < T > & , T) throw (IllegalAction, OutOfMemory);","    T removeCurrent(ListIterator < T > & ) throw (IllegalAction);","","    bool set(int, T) throw (IndexOutOfBounds);","    int indexOf(T) const;","    int lastIndexOf(T) const;","    T remove(int) throw (IndexOutOfBounds);","    bool removeFirstOcurrence(T);","    bool removeLastOcurrence(T);","","    private:","      Link < T > * head;","    int size;","","    friend class ListIterator < T > ;","  };","","template < class T >","  List < T > ::List(): head(0), size(0) {}","","template < class T >","  List < T > ::~List() {","    clear();","  }","","template < class T >","  bool List < T > ::empty() const {","    return (head == 0);","  }","","template < class T >","  int List < T > ::length() const {","    return size;","  }","","template < class T >","  bool List < T > ::contains(T val) const {","    Link < T > * p;","","    p = head;","    while (p != 0) {","      if (p -> value == val) {","        return true;","      }","      p = p -> next;","    }","    return false;","  }","","template < class T >","  T List < T > ::getFirst() const","throw (NoSuchElement) {","  if (empty()) {","    throw NoSuchElement();","  }","  return head -> value;","}","","template < class T >","  void List < T > ::addFirst(T val) throw (OutOfMemory) {","    Link < T > * newLink;","","    newLink = new Link < T > (val);","    if (newLink == 0) {","      throw OutOfMemory();","    }","    newLink -> next = head;","    head = newLink;","    size++;","  }","","template < class T >","  void List < T > ::add(T val) throw (OutOfMemory) {","    Link < T > * newLink, * p;","","    newLink = new Link < T > (val);","    if (newLink == 0) {","      throw OutOfMemory();","    }","","    if (empty()) {","      addFirst(val);","      return;","    }","","    p = head;","    while (p -> next != 0) {","      p = p -> next;","    }","","    newLink -> next = 0;","    p -> next = newLink;","    size++;","  }","","template < class T >","  T List < T > ::removeFirst() throw (NoSuchElement) {","    T val;","    Link < T > * p;","","    if (empty()) {","      throw NoSuchElement();","    }","","    p = head;","","    head = p -> next;","    val = p -> value;","","    delete p;","    size--;","","    return val;","  }","","template < class T >","  T List < T > ::get(int index) const","throw (IndexOutOfBounds, NoSuchElement) {","  int pos;","  Link < T > * p;","","  if (index < 0 || index >= size) {","    throw IndexOutOfBounds();","  }","","  if (index == 0) {","    return getFirst();","  }","","  p = head;","  pos = 0;","  while (pos != index) {","    p = p -> next;","    pos++;","  }","","  return p -> value;","}","","template < class T >","  void List < T > ::clear() {","    Link < T > * p, * q;","","    p = head;","    while (p != 0) {","      q = p -> next;","      delete p;","      p = q;","    }","    head = 0;","    size = 0;","  }","","template < class T >","  std::string List < T > ::toString() const {","    std::stringstream aux;","    Link < T > * p;","","    p = head;","    aux << \"[\";","    while (p != 0) {","      aux << p -> value;","      if (p -> next != 0) {","        aux << \", \";","      }","      p = p -> next;","    }","    aux << \"]\";","    return aux.str();","  }","","template < class T >","  List < T > ::List(const List < T > & source) throw (OutOfMemory) {","    Link < T > * p, * q;","","    if (source.empty()) {","      size = 0;","      head = 0;","    } else {","      p = source.head;","      head = new Link < T > (p -> value);","      if (head == 0) {","        throw OutOfMemory();","      }","      q = head;","","      p = p -> next;","      while (p != 0) {","        q -> next = new Link < T > (p -> value);","        if (q -> next == 0) {","          throw OutOfMemory();","        }","        p = p -> next;","        q = q -> next;","      }","      size = source.size;","    }","  }","","template < class T >","  void List < T > ::operator = (const List < T > & source) throw (OutOfMemory) {","    Link < T > * p, * q;","","    clear();","    if (source.empty()) {","      size = 0;","      head = 0;","    } else {","      p = source.head;","      head = new Link < T > (p -> value);","      if (head == 0) {","        throw OutOfMemory();","      }","      q = head;","","      p = p -> next;","      while (p != 0) {","        q -> next = new Link < T > (p -> value);","        if (q -> next == 0) {","          throw OutOfMemory();","        }","        p = p -> next;","        q = q -> next;","      }","      size = source.size;","    }","  }","","template < class T >","  void List < T > ::addBefore(ListIterator < T > & itr, T val) throw (IllegalAction, OutOfMemory) {","    Link < T > * newLink;","","    if (this != itr.theList) {","      throw IllegalAction();","    }","","    newLink = new Link < T > (val);","    if (newLink == 0) {","      throw OutOfMemory();","    }","","    // between","    if (itr.previous != 0) {","      newLink -> next = itr.current;","      itr.previous -> next = newLink;","      itr.previous = itr.previous -> next;","      size++;","      // start","    } else {","      addFirst(val);","      itr.previous = head;","      itr.current = itr.previous -> next;","    }","  }","","template < class T >","  void List < T > ::addAfter(ListIterator < T > & itr, T val) throw (IllegalAction, OutOfMemory) {","    Link < T > * newLink;","","    if (this != itr.theList) {","      throw IllegalAction();","    }","","    newLink = new Link < T > (val);","    if (newLink == 0) {","      throw OutOfMemory();","    }","","    // between","    if (itr.current != 0) {","      newLink -> next = itr.current -> next;","      itr.current -> next = newLink;","      size++;","      // end","    } else if (itr.previous != 0) {","      itr.previous -> next = newLink;","      itr.current = newLink;","      size++;","      // start","    } else {","      addFirst(val);","      itr.current = head;","      itr.previous = 0;","    }","  }","","template < class T >","  T List < T > ::removeCurrent(ListIterator < T > & itr) throw (IllegalAction) {","    T val;","","    if (this != itr.theList) {","      throw IllegalAction();","    }","","    if (itr.current == 0) {","      throw NoSuchElement();","    }","","    if (itr.previous == 0) {","      head = itr.current -> next;","    } else {","      itr.previous -> next = itr.current -> next;","    }","","    val = itr.current -> value;","    delete itr.current;","    itr.current = 0;","","    //std::cout << \"remove current = \" << ((itr.current != 0)? itr.current->value : 0) << \" previous: \" << ((itr.previous != 0)? itr.previous->value : 0) << std::endl;","    return val;","  }","","template < class T >","  bool List < T > ::set(int index, T val) throw (IndexOutOfBounds) {","    if (index >= size) {","      throw IndexOutOfBounds();","    }","    if (index < 0) {","      throw IndexOutOfBounds();","    }","    Link < T > * p;","    p = head;","    int i = 0;","    while (i < index) {","      p = p -> next;","      i++;","","    }","    p -> value = val;","    return true;","","  }","","template < class T >","  int List < T > ::indexOf(T val) const {","    Link < T > * p;","    p = head;","    int i = 0;","","    while (p -> value != val) {","      p = p -> next;","      i++;","","    }","    return i;","","  }","","template < class T >","  int List < T > ::lastIndexOf(T val) const {","","    int i = 0;","    int ultimo = -1;","    Link < T > * p;","    p = head;","","    while (i < size) {","      if (p -> value == val) {","        ultimo = i;","      }","      i++;","      p = p -> next;","    }","","    return ultimo;","","  }","","template < class T >","  T List < T > ::remove(int index) throw (IndexOutOfBounds) {","","    if (index >= size) {","      throw IndexOutOfBounds();","    }","    if (index < 0) {","      throw IndexOutOfBounds();","    }","","    Link < T > * p;","    Link < T > * q;","    T val;","    p = head;","    int i = 0;","","    while ((i != index - 1)) {","      p = p -> next;","      i++;","    }","","    q = p -> next;","    val = q -> value;","    p -> next = p -> next -> next;","","    delete q;","    size--;","    return val;","","  }","","template < class T >","  bool List < T > ::removeFirstOcurrence(T val) {","","    Link < T > * p;","    Link < T > * q;","    int i = 0;","    p = head;","","    while (i < size - 1) {","      q = p -> next;","      if (q -> value == val) {","        p -> next = p -> next -> next;","        delete q;","        size--;","        return true;","      }","      i++;","      p = p -> next;","    }","","    return false;","","  }","","template < class T >","  bool List < T > ::removeLastOcurrence(T val) {","    Link < T > * p;","    Link < T > * q;","    int i = 0;","    p = head;","","    while (i < size - 1) {","      q = p -> next;","      if (q -> value == val) {","        p -> next = p -> next -> next;","        delete q;","        size--;","        return true;","      }","      i++;","      p = p -> next;","    }","","    return false;","  }","","//clase iterador","template < class T >","  class ListIterator {","    public:","      ListIterator(List < T > * );","    ListIterator(const ListIterator < T > & );","","    bool begin();","    bool end();","    T & operator()() throw (NoSuchElement);","    bool operator++();","    void operator = (T) throw (NoSuchElement);","","    private:","      Link < T > * current;","    Link < T > * previous;","    List < T > * theList;","","    friend class List < T > ;","  };","","template < class T >","  ListIterator < T > ::ListIterator(List < T > * aList): theList(aList) {","    begin();","  }","","template < class T >","  ListIterator < T > ::ListIterator(const ListIterator < T > & source): theList(source.theList) {","    begin();","  }","","template < class T >","  bool ListIterator < T > ::begin() {","    previous = 0;","    current = theList -> head;","    return (current != 0);","  }","","template < class T >","  T & ListIterator < T > ::operator()() throw (NoSuchElement) {","    if (current == 0) {","      throw NoSuchElement();","    }","    return current -> value;","  }","","template < class T >","  bool ListIterator < T > ::end() {","    //std::cout << \"1 end current = \" << ((current != 0)? current->value : 0) << \" previous: \" << ((previous != 0)? previous->value : 0) << std::endl;","    if (current == 0) {","      if (previous != 0) {","        current = previous -> next;","      }","    }","    return (current == 0);","  }","","template < class T >","  bool ListIterator < T > ::operator++() {","    if (current == 0) {","      if (previous == 0) {","        current = theList -> head;","      } else {","        current = previous -> next;","      }","    } else {","      previous = current;","      current = current -> next;","    }","    return (current != 0);","  }","","template < class T >","  void ListIterator < T > ::operator = (T val) throw (NoSuchElement) {","    if (current == 0) {","      throw NoSuchElement();","    }","    current -> value = val;","  }","","#endif /* LINKEDLIST_H_ */"]}]]},"timestamp":1474086218000}